{"version":3,"file":"recognize.js","sourceRoot":"","sources":["../../../../../modules/@angular/router/src/recognize.ts"],"names":[],"mappings":"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","sourcesContent":["import {BaseException, ComponentFactory, ComponentResolver} from '@angular/core';\n\nimport {DEFAULT_OUTLET_NAME} from './constants';\nimport {reflector} from './core_private';\nimport {ListWrapper, StringMapWrapper} from './facade/collection';\nimport {Type, isBlank, isPresent, stringify} from './facade/lang';\nimport {PromiseWrapper} from './facade/promise';\nimport {RouteMetadata, RoutesMetadata} from './metadata/metadata';\nimport {RouteSegment, RouteTree, Tree, TreeNode, UrlSegment, UrlTree, equalUrlSegments, rootNode} from './segments';\n\nexport function recognize(\n    componentResolver: ComponentResolver, rootComponent: Type, url: UrlTree,\n    existingTree: RouteTree): Promise<RouteTree> {\n  let matched = new _MatchResult(rootComponent, [url.root], {}, rootNode(url).children, []);\n  return _constructSegment(componentResolver, matched, rootNode(existingTree))\n      .then(roots => new RouteTree(roots[0]));\n}\n\nfunction _recognize(\n    componentResolver: ComponentResolver, parentComponent: Type, url: TreeNode<UrlSegment>,\n    existingSegments: TreeNode<RouteSegment>[]): Promise<TreeNode<RouteSegment>[]> {\n  let metadata = _readMetadata(parentComponent);  // should read from the factory instead\n  if (isBlank(metadata)) {\n    throw new BaseException(\n        `Component '${stringify(parentComponent)}' does not have route configuration`);\n  }\n\n  let match: any /** TODO #9100 */;\n  try {\n    match = _match(metadata, url);\n  } catch (e) {\n    return PromiseWrapper.reject(e, null);\n  }\n\n  let segmentsWithRightOutlet = existingSegments.filter(r => r.value.outlet == match.outlet);\n  let segmentWithRightOutlet =\n      segmentsWithRightOutlet.length > 0 ? segmentsWithRightOutlet[0] : null;\n\n  let main = _constructSegment(componentResolver, match, segmentWithRightOutlet);\n  let aux = _recognizeMany(componentResolver, parentComponent, match.aux, existingSegments)\n                .then(_checkOutletNameUniqueness);\n  return PromiseWrapper.all([main, aux]).then(ListWrapper.flatten);\n}\n\nfunction _recognizeMany(\n    componentResolver: ComponentResolver, parentComponent: Type, urls: TreeNode<UrlSegment>[],\n    existingSegments: TreeNode<RouteSegment>[]): Promise<TreeNode<RouteSegment>[]> {\n  let recognized =\n      urls.map(u => _recognize(componentResolver, parentComponent, u, existingSegments));\n  return PromiseWrapper.all(recognized).then(ListWrapper.flatten);\n}\n\nfunction _constructSegment(\n    componentResolver: ComponentResolver, matched: _MatchResult,\n    existingSegment: TreeNode<RouteSegment>): Promise<TreeNode<RouteSegment>[]> {\n  return componentResolver.resolveComponent(matched.component).then(factory => {\n    let segment = _createOrReuseSegment(matched, factory, existingSegment);\n    let existingChildren = isPresent(existingSegment) ? existingSegment.children : [];\n\n    if (matched.leftOverUrl.length > 0) {\n      return _recognizeMany(\n                 componentResolver, factory.componentType, matched.leftOverUrl, existingChildren)\n          .then(children => [new TreeNode<RouteSegment>(segment, children)]);\n    } else {\n      return _recognizeLeftOvers(componentResolver, factory.componentType, existingChildren)\n          .then(children => [new TreeNode<RouteSegment>(segment, children)]);\n    }\n  });\n}\n\nfunction _createOrReuseSegment(\n    matched: _MatchResult, factory: ComponentFactory<any>,\n    segmentNode: TreeNode<RouteSegment>): RouteSegment {\n  let segment = isPresent(segmentNode) ? segmentNode.value : null;\n\n  if (isPresent(segment) && equalUrlSegments(segment.urlSegments, matched.consumedUrlSegments) &&\n      StringMapWrapper.equals(segment.parameters, matched.parameters) &&\n      segment.outlet == matched.outlet && factory.componentType == segment.type) {\n    return segment;\n  } else {\n    return new RouteSegment(\n        matched.consumedUrlSegments, matched.parameters, matched.outlet, factory.componentType,\n        factory);\n  }\n}\n\nfunction _recognizeLeftOvers(\n    componentResolver: ComponentResolver, parentComponent: Type,\n    existingSegments: TreeNode<RouteSegment>[]): Promise<TreeNode<RouteSegment>[]> {\n  return componentResolver.resolveComponent(parentComponent).then(factory => {\n    let metadata = _readMetadata(factory.componentType);\n    if (isBlank(metadata)) {\n      return [];\n    }\n\n    let r = (<any[]>metadata.routes).filter(r => r.path == '' || r.path == '/');\n    if (r.length === 0) {\n      return PromiseWrapper.resolve([]);\n    } else {\n      let segmentsWithMatchingOutlet =\n          existingSegments.filter(r => r.value.outlet == DEFAULT_OUTLET_NAME);\n      let segmentWithMatchingOutlet =\n          segmentsWithMatchingOutlet.length > 0 ? segmentsWithMatchingOutlet[0] : null;\n      let existingChildren =\n          isPresent(segmentWithMatchingOutlet) ? segmentWithMatchingOutlet.children : [];\n\n      return _recognizeLeftOvers(componentResolver, r[0].component, existingChildren)\n          .then(children => {\n            return componentResolver.resolveComponent(r[0].component).then(factory => {\n              let segment = _createOrReuseSegment(\n                  new _MatchResult(r[0].component, [], {}, [], []), factory,\n                  segmentWithMatchingOutlet);\n              return [new TreeNode<RouteSegment>(segment, children)];\n            });\n          });\n    }\n  });\n}\n\nfunction _match(metadata: RoutesMetadata, url: TreeNode<UrlSegment>): _MatchResult {\n  for (let r of metadata.routes) {\n    let matchingResult = _matchWithParts(r, url);\n    if (isPresent(matchingResult)) {\n      return matchingResult;\n    }\n  }\n  let availableRoutes = metadata.routes.map(r => `'${r.path}'`).join(', ');\n  throw new BaseException(\n      `Cannot match any routes. Current segment: '${url.value}'. Available routes: [${availableRoutes}].`);\n}\n\nfunction _matchWithParts(route: RouteMetadata, url: TreeNode<UrlSegment>): _MatchResult {\n  let path = route.path.startsWith('/') ? route.path.substring(1) : route.path;\n\n  if (path == '*') {\n    return new _MatchResult(route.component, [], null, [], []);\n  }\n\n  let parts = path.split('/');\n  let positionalParams = {};\n  let consumedUrlSegments: any[] /** TODO #9100 */ = [];\n\n  let lastParent: TreeNode<UrlSegment> = null;\n  let lastSegment: TreeNode<UrlSegment> = null;\n\n  let current = url;\n  for (let i = 0; i < parts.length; ++i) {\n    if (isBlank(current)) return null;\n\n    let p = parts[i];\n    let isLastSegment = i === parts.length - 1;\n    let isLastParent = i === parts.length - 2;\n    let isPosParam = p.startsWith(':');\n\n    if (!isPosParam && p != current.value.segment) return null;\n    if (isLastSegment) {\n      lastSegment = current;\n    }\n    if (isLastParent) {\n      lastParent = current;\n    }\n\n    if (isPosParam) {\n      (positionalParams as any /** TODO #9100 */)[p.substring(1)] = current.value.segment;\n    }\n\n    consumedUrlSegments.push(current.value);\n\n    current = ListWrapper.first(current.children);\n  }\n\n  let p = lastSegment.value.parameters;\n  let parameters = <{[key: string]: string}>StringMapWrapper.merge(p, positionalParams);\n  let axuUrlSubtrees = isPresent(lastParent) ? lastParent.children.slice(1) : [];\n\n  return new _MatchResult(\n      route.component, consumedUrlSegments, parameters, lastSegment.children, axuUrlSubtrees);\n}\n\nfunction _checkOutletNameUniqueness(nodes: TreeNode<RouteSegment>[]): TreeNode<RouteSegment>[] {\n  let names = {};\n  nodes.forEach(n => {\n    let segmentWithSameOutletName = (names as any /** TODO #9100 */)[n.value.outlet];\n    if (isPresent(segmentWithSameOutletName)) {\n      let p = segmentWithSameOutletName.stringifiedUrlSegments;\n      let c = n.value.stringifiedUrlSegments;\n      throw new BaseException(`Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n    }\n    (names as any /** TODO #9100 */)[n.value.outlet] = n.value;\n  });\n  return nodes;\n}\n\nclass _MatchResult {\n  constructor(\n      public component: Type|string, public consumedUrlSegments: UrlSegment[],\n      public parameters: {[key: string]: string}, public leftOverUrl: TreeNode<UrlSegment>[],\n      public aux: TreeNode<UrlSegment>[]) {}\n\n  get outlet(): string {\n    return this.consumedUrlSegments.length === 0 || isBlank(this.consumedUrlSegments[0].outlet) ?\n        DEFAULT_OUTLET_NAME :\n        this.consumedUrlSegments[0].outlet;\n  }\n}\n\nfunction _readMetadata(componentType: Type) {\n  let metadata = reflector.annotations(componentType).filter(f => f instanceof RoutesMetadata);\n  return ListWrapper.first(metadata);\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}